\documentclass[10pt,a4paper]{amsart}
% \documentclass[10pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{indentfirst}
\usepackage{framed}
%to bind figures in respective sections
\usepackage[section]{placeins}
%to number figures considering the section
\usepackage{chngcntr}
\counterwithin{figure}{section}

%for pseudocode
% \usepackage[]{algorithm2e}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\floatname{algorithm}{Algoritmo}
\renewcommand{\algorithmicrequire}{\textbf{Entrada:}}
\renewcommand{\algorithmicensure}{\textbf{Saída:}}
\renewcommand{\algorithmicwhile}{\textbf{Enquanto}}
\renewcommand{\algorithmicdo}{\textbf{faça}}
\renewcommand{\algorithmicfor}{\textbf{Para}}
\renewcommand{\algorithmicif}{\textbf{Se}}
\renewcommand{\algorithmicthen}{\textbf{então}}

% for pretty-printed source code
\usepackage{listings}
% environment for C code
\lstnewenvironment{code}
 {\lstset{ %
     extendedchars=true,
     stringstyle=\ttfamily \scriptsize, %
     showstringspaces=false, aboveskip={1.\baselineskip}, %
     identifierstyle=\ttfamily \scriptsize \bf, %
     language=C,           %
     basicstyle=\ttfamily \small,  %\footnotesize
     numberstyle=\footnotesize, %
     % keywordstyle=\bf,       % keyword style
     tabsize=1,                 % sets default tabsize to 2 spaces
     captionpos=t,              % sets the caption-position to bottom
     breaklines=true,           % sets automatic line breaking
     breakatwhitespace=false,   % sets if automatic breaks should only happen at whitespace
     %backgroundcolor=\color{black!10},
   }
} {}

\author{Jo\~ao S. Brito Jr.\\NUSP: 5889672}
\title{Laboratório de Inteligência Artificial: \\Revisão de Crenças}
\date{\today}
\usepackage{graphicx}
\graphicspath{ {images/} }

\begin{document}

\begin{abstract}
  % Resumo
  Este documento descreve a implementação de uma abordagem para revisão de crenças que funciona da seguinte forma: dado um arquivo de entrada com uma base de crenças e um conjunto de sentenças para revisão, o programa gera uma nova base de crenças que contém as sentenças do conjunto de revisão e a maior quantidade possível de crenças da base original mantendo a consistência.
  Em seguida, apresentamos alguns comentários sobre os testes efetuados.
\end{abstract}

\maketitle

% \section{Introdução}

\section{Implementação}
%   descrição da implementação
O programa implementado recebe como entrada uma base de crenças \textbf{K}, e um conjunto de sentenças para revisão \textbf{R} e cria uma base auxiliar \textbf{K'} substituindo os átomos que são comuns a \textbf{K} e \textbf{R} por novos átomos auxiliares não pertencentes a linguagem (para cada átomo $p$, substituir por $p'$).

Definimos que um conjunto de equivalências é um conjunto de cláusulas do tipo $p \equiv p'$, e utilizamos estas cláusulas para igualar um átomo a seu respectivo auxiliar.

Com a base auxiliar \textbf{K'} buscamos encontrar os maiores conjuntos de equivalência possíveis que mantenham consistente (satisfatível) a base resultante da união de \textbf{K'} e \textbf{R}.

Para cada conjunto de equivalências maximal geramos uma base revisada. Os átomos $p'$ que pertencem ao conjunto maximal são substituídos por $p$ e os que não pertencem são substituídos por $\neg ~p$.

Por fim, as possíveis bases revisadas são gravadas no arquivo de saída informado pelo usuário.

Em nossa implementação os conjuntos de equivalências maximais são obtidos através do método \emph{get\_max\_equivalence\_sets()} que recebe como entrada a lista de átomos comuns a \textbf{K} e \textbf{R}, e a base que corresponde à união de \textbf{K'} e \textbf{R}.

Este método itera por todas as combinações possíveis de elementos da lista de átomos em ordem descendente de tamanho. Para cada combinação, gera-se o conjunto de equivalências e efetua-se o teste de satisfabilidade. Se o conjunto for aprovado é adicionado a lista de conjuntos maximais.

Para evitar chamadas desnecessárias ao SAT, o procedimento ignora os conjuntos que são subconjuntos de um maximal previamente conhecido, ou que são superconjuntos de algum dos conjuntos mínimos que geram inconsistência.

A ordem descendente de tamanho das combinações foi escolhida por reduzir a quantidade de chamadas ao SAT nos testes efetuados.

\section{Instruções de execução}
O código foi implementado em \emph{Python 2.7} e utiliza a biblioteca \emph{sympy} para converter expressões lógicas para CNF e efetuar a verificação de satisfatibilidade.

Para executar, pode-se utilizar o seguinte comando:
\begin{itemize}
 \item[] \emph{python main.py <belief-base> <new-information> <revised-base>}
 \item[] ex: \emph{python main.py KB.txt R.txt result.txt}
\end{itemize}

Onde \emph{<belief-base>} é o arquivo contendo as crenças iniciais, \emph{<new-information>} contêm as sentenças para revisão e \emph{<revised-base>} é o arquivo resultado com as possíveis escolhas de bases revisadas.

\section{Testes e comentários}
%   incluir testes/ resultados e uma subseção com comentários pessoais
%   configuração dos experimentos: computador, parâmetros utilizados
% Todos os experimentos foram efetuados em uma máquina com processador Intel Core 2 Duo 2.10GHz com 4GB de memória.

\subsection{Problema dos animais voadores}
Neste exemplo, consideramos que um animal voador foi observado e que acreditamos ser um morcego. Além disso, temos algumas crenças sobre animais voadores:

\begin{framed}
K:

$tem\_asas$

$morcego$

$passaro \Rightarrow poe\_ovo$

$tem\_asas \Rightarrow voador$

$tem\_asas \Rightarrow passaro$

$passaro \Rightarrow tem\_asas$
\end{framed}

Podemos observar que há uma crença "problemática": $tem\_asas \Rightarrow passaro$, que nos leva a concluir que o animal que vimos é um pássaro.

Em seguida aprendemos uma nova informação: morcegos não podem ser pássaros.
\begin{framed}
R:

$morcego \Rightarrow \neg passaro$
\end{framed}

Ao considerar a nova informação, o programa fornece duas possíveis revisões.
A primeira delas (K 1) seria considerar que o animal que vimos não é um morcego, o que parece razoável.

\begin{framed}
K 1:

$tem\_asas$

$\neg morcego$

$(passaro \lor \neg tem_asas)$

$(poe\_ovo \lor \neg passaro)$

$(tem\_asas \lor \neg passaro)$

$(voador \lor \neg tem\_asas)$

$(\neg morcego \lor \neg passaro)$
\end{framed}

\begin{framed}
K 2:

$morcego$

$tem\_asas$

$(passaro \lor poe\_ovo)$

$(passaro \lor tem\_asas)$

$(voador \lor \neg tem\_asas)$

$(\neg morcego \lor \neg passaro)$

$(\neg passaro \lor \neg tem\_asas)$
\end{framed}

Porém na segunda opção (K 2), para manter a crença em "morcego" e manter a consistência, o átomo "pássaro" é negado.
Isso acaba modificando todas as crenças prévias que tínhamos sobre pássaros. Por exemplo, deixamos de acreditar que todos os pássaros necessariamente têm asas, e passamos a crer que os não pássaros necessariamente põem ovos.

\subsection{Problema dos apaixonados}
Este domínio modela a situação em que um apaixonado revisa o que acredita em relação à sua amada. Os testes foram efetuados com a base completa, porém nesta discussão focaremos apenas em algumas sentenças específicas.

A base inicial contem, entre outras, as duas sentenças a seguir:
\begin{framed}
K:

$amada\_ama$

$(amada\_ama \land apaixonado\_chama\_pra\_sair \land fim\_de\_semana)
\\ \Rightarrow amada\_aceita\_sair$
\end{framed}

E fazemos a seguinte revisão, que é conflitante com o trecho da base que apresentamos:
\begin{framed}
R:

$(apaixonado\_chama\_pra\_sair \land fim\_de\_semana \land \neg amada\_aceita\_sair)$
\end{framed}

Com esta revisão temos três possibilidades de base de crenças. Mostramos abaixo cada uma delas (parcialmente).
\begin{framed}
K 1:

$(amada\_aceita\_sair \lor fim\_de\_semana \lor \neg amada\_ama \lor \neg apaixonado\_chama\_pra\_sair)$

K 2:

$(amada\_aceita\_sair \lor amada\_ama \lor \neg apaixonado\_chama\_pra\_sair \lor \neg fim\_de\_semana)$

K 3:

$(amada\_aceita\_sair \lor apaixonado\_chama\_pra\_sair \lor \neg amada\_ama \lor \neg fim\_de\_semana)$
 
\end{framed}

Podemos ver que cada uma das três opções modifica algum átomo da regra que causa a inconsistência.
Uma outra possível alternativa para acomodar a nova informação obtida, poderia ser negar a crença "amada\_ama". Porém, como o algoritmo considera apenas os átomos que estão presentes em ambos \textbf{K} e \textbf{R} para efetuar as substituições, a opção de negar "amada\_ama" não é considerada.


% As figuras abaixo mostram os resultados obtidos:
% Fig. ~\ref{fig:mid_layer_2_10}
% \begin{figure}[ht]
%   \centering
%   \includegraphics[width=\textwidth]{mid_layer_2_10}
%   \caption{Tempo em função do número de camadas. Problemas SSP gerados artificialmente com 5000 estados, 10 ações por estado, máximo de 10 sucessores por ação. Custo aleatório entre 2 e 10.}
%   \label{fig:mid_layer_2_10}
% \end{figure}

% \section{Conclusão}

% \begin{thebibliography}{9}
% \bibitem{dai11}
%   Dai, P., Weld, D. S., Goldsmith, J. (2011). Topological value iteration algorithms. Journal of Artificial Intelligence Research, 181-209.
% \end{thebibliography}

\end{document}
